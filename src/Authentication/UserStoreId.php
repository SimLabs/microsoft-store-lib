<?php

namespace MicrosoftStoreLib\Authentication;

use GuzzleHttp\Promise\PromiseInterface;
use GuzzleHttp\Psr7\Response;
use MicrosoftStoreLib\DefaultGazzleHttpFactory;
use MicrosoftStoreLib\IHttpClientFactory;
use MicrosoftStoreLib\Serializer;

class UserStoreIdType
{
    const UserCollectionsId = 0;
    const UserPurchaseId = 1;
    const Unknown = 2;
}

/// <summary>
/// The different Audience values that determine which type of USerAccessToken is being used
/// </summary>
class UserStoreIdAudiences
{
    //  These are the audience values for each access token type
    public const UserCollectionsId = "https://collections.mp.microsoft.com/v6.0/keys";
    public const UserPurchaseId    = "https://purchase.mp.microsoft.com/v6.0/keys";
}

/// <summary>
/// Extracts useful claims info from a UserStoreId (general term for either a UserCollectionsId
/// or UserPurchaseId) and provides utility function to refresh an expired key
/// </summary>
class UserStoreId
{
    /// <summary>
    /// Can be overridden with an HttpClientFactory.CreateClient() if used by your service.
    /// Ex: UserStoreId.CreateHttpClientFunc = httpClientFactory.CreateClient;
    /// </summary>
    public IHttpClientFactory $CreateHttpClientFunc;

    /// <summary>
    /// URI that allows this token to be refreshed once it expires.
    /// </summary>
    public string $RefreshUri;

    /// <summary>
    /// Identifies which type of UserStoreId this is based on the audience value
    /// UserCollectionsId (https://collections.mp.microsoft.com/v6.0/keys) or
    /// UserPurchaseId (https://purchase.mp.microsoft.com/v6.0/keys).
    /// </summary>
    public UserStoreIdType $KeyType;

    /// <summary>
    /// UTC date time when the key will expire, this is longer than the recommended
    /// refresh time which we track with RefreshAfter
    /// </summary>
    public \DateTime $Expires;

    /// <summary>
    /// UTC date that you should refresh the token to ensure it stays valid
    /// which is every 2 weeks.
    /// </summary>
    public \DateTime $RefreshAfter;

    /// <summary>
    /// The UserStoreId that was used to generate this object and would be
    /// used as the beneficiary in a b2b call for authentication.
    /// </summary>
    public string $Key;

    /// <summary>
    /// Creates a UserStoreId based on the storeIdKey JWT's claims
    /// </summary>
    /// <param name="storeIdKey">JWT representing the UserStoreId</param>
    public function __construct(string $storeIdKey)
    {
        $this->CreateHttpClientFunc = new DefaultGazzleHttpFactory();
        $this->UpdateKeyInformation($storeIdKey);
    }

    private function UpdateKeyInformation(string $storeIdKey)
    {
        //  We can use the values in the payload to know how and when to
        //  refresh it.
        $keyClaims = Serializer::Get()->deserialize(
            base64_decode(explode('.', $storeIdKey)[1]),
            UserStoreIdClaims::class,
            'json'
        );
        $this->RefreshUri = $keyClaims->RefreshUri;
        $this->Expires = $keyClaims->ExpiresOn;
        $this->Key = $storeIdKey;

        //  Recommended time to refresh the ticket is every 2 weeks
        $this->RefreshAfter = $keyClaims->IssuedOn->add(new \DateInterval("PD14T"));

        if ($keyClaims->Audience === UserStoreIdAudiences::UserCollectionsId) {
            $this->KeyType = UserStoreIdType::UserCollectionsId;
        } else if ($keyClaims->Audience === UserStoreIdAudiences::UserPurchaseId) {
            $this->KeyType = UserStoreIdType::UserPurchaseId;
        } else {
            $this->KeyType = UserStoreIdType::Unknown;
        }
    }

    /// <summary>
    /// Uses the RefreshURI to generate a new UserStoreId key for this user once the current one is expired
    /// </summary>
    /// <param name="expiredStoreId">The UserStoreId that we want to refresh</param>
    /// <param name="serviceToken">AAD token generated by your service with the audience of https://onestore.microsoft.com </param>
    /// <param name="httpClient">HttpClient to be used to make the refresh call</param>
    /// <returns>A new UserStoreId for the same store user with new expire date</returns>
    public function RefreshStoreId(string $serviceToken): PromiseInterface/*<bool>*/
    {
        $refreshRequest = new UserStoreIdRefreshRequest();
        $refreshRequest->ServiceToken = $serviceToken;
        $refreshRequest->UserStoreId = $this->Key;

        $requestBodyString = Serializer::Get()->serialize($refreshRequest, 'json');

        //  call the refresh
        $httpClient = $this->CreateHttpClientFunc::Create();
        return $httpClient->requestAsync('POST', $this->RefreshUri, [], $requestBodyString)->then(function (Response $httpResponse) {
            $responseBody = $httpResponse->getBody();
            $response = Serializer::Get()->deserialize($responseBody, UserStoreIdRefreshResponse::class, 'json');
            $this->UpdateKeyInformation($response->Key);
            return true;
        });
    }
}
